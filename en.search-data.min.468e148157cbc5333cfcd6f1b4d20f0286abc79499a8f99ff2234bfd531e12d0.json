[{"id":0,"href":"/neural-book/docs/book/","title":"Introdução","section":"Docs","content":"Introdução# O que é o NeuralBook?# O NeuralBook é um guia didático voltado para estudantes e profissionais de Engenharia que desejam aprender a utilizar Python e suas principais bibliotecas aplicadas ao aprendizado de máquina e às redes neurais artificiais.\nEste material foi pensado no formato de documentação estruturada e acessível, semelhante a um livro online técnico, permitindo tanto uma consulta rápida quanto um estudo progressivo e aprofundado.\nObjetivo# O objetivo central do NeuralBook é capacitar engenheiros e discentes a utilizar ferramentas modernas de ciência de dados e inteligência artificial na resolução de problemas da Engenharia.\nPara isso, o material integra manipulação de dados, modelagem matemática e implementação de redes neurais artificiais, sempre com foco em aplicações práticas.\nO que você vai encontrar aqui# Fundamentos do Python para Engenharia\nEstruturas básicas da linguagem e introdução às bibliotecas NumPy, Pandas e Matplotlib.\nManipulação e Visualização de Dados\nTécnicas para leitura, tratamento e análise de conjuntos de dados reais ou simulados.\nBibliotecas de Machine Learning\nModelagem preditiva e classificatória com Scikit-learn.\nRedes Neurais Artificiais\nConceitos fundamentais e implementação com Keras e TensorFlow.\nAplicações em Engenharia\nEstudos de caso e resolução de problemas práticos nas áreas de Engenharia Química, Produção, Elétrica e Mecânica.\nPúblico-alvo# Este material foi desenvolvido para:\nEstudantes de graduação em Engenharia. Professores que desejam adotar um material de apoio interdisciplinar. Profissionais interessados em aplicar redes neurais e aprendizado de máquina em seus projetos. Filosofia# NeuralBook é um ponto de partida para integrar Engenharia e Inteligência Artificial, oferecendo exemplos de código comentados, exercícios práticos e estudos de caso aplicados.\n"},{"id":1,"href":"/neural-book/docs/book/python-basico/","title":"Python Básico","section":"Introdução","content":"Python Básico# Esta seção apresenta os fundamentos do Python e suas bibliotecas essenciais para a Engenharia:\nNumPy (cálculos matriciais e vetoriais) Pandas (manipulação de dados tabulares) Matplotlib (visualização gráfica) O objetivo é fornecer a base necessária para avançar em Machine Learning e Redes Neurais.\n"},{"id":2,"href":"/neural-book/docs/book/python-basico/numpy/","title":"NumPy","section":"Python Básico","content":"NumPy# O NumPy é a biblioteca fundamental para cálculos numéricos em Python.\nEla fornece arrays multidimensionais de alta performance e funções matemáticas otimizadas.\nEm Engenharia, NumPy é usada para representar vetores, matrizes, resolver sistemas lineares, fazer simulações numéricas e preparar dados para modelos de machine learning.\nObjetivo deste capítulo: apresentar os conceitos essenciais do NumPy, com exemplos práticos.\nÍndice rápido# Criando arrays Sequências numéricas: arange vs linspace Aleatoriedade e reprodutibilidade Shape, ndim e dtype Indexação e slicing Operações vetorizadas \u0026amp; broadcasting Álgebra linear básica Estatísticas e funções úteis Referências rápidas Criando arrays# A forma mais comum de criar um array é a partir de uma lista Python.\nimport numpy as np # Criando um array 1D (vetor) a partir de uma lista de números decimais a = np.array([1.2, 2.4, 3.5]) # Criando um array 2D (matriz 2x2) a partir de uma lista de listas M = np.array([[1, 2], [3, 4]]) # Vamos inspecionar nossos arrays print(\u0026#34;Vetor \u0026#39;a\u0026#39;:\u0026#34;, a) print(\u0026#34;Tipo de dado de \u0026#39;a\u0026#39;:\u0026#34;, a.dtype) # dtype = data type (tipo de dado) print(\u0026#34;Formato de \u0026#39;a\u0026#39;:\u0026#34;, a.shape) # shape = formato (dimensões) print(\u0026#34;\\nMatriz \u0026#39;M\u0026#39;:\\n\u0026#34;, M) print(\u0026#34;Tipo de dado de \u0026#39;M\u0026#39;:\u0026#34;, M.dtype) print(\u0026#34;Formato de \u0026#39;M\u0026#39;:\u0026#34;, M.shape)O que significam dtype e shape?\nInforma o tipo de dado armazenado no array. float64 representa números de ponto flutuante com 64 bits de precisão (o padrão para decimais). int64 representa inteiros. Manter todos os elementos com o mesmo tipo é um dos segredos da eficiência do NumPy. shape: É uma tupla que descreve as dimensões do array. (3,) significa que é um array de 1 dimensão com 3 elementos (um vetor de comprimento 3). (2, 2) significa que é um array de 2 dimensões, com 2 linhas e 2 colunas (uma matriz 2x2). Sequências numéricas# Para análises e gráficos, frequentemente precisamos gerar sequências de números. O NumPy oferece duas funções principais para isso:\nnp.arange(início, fim, passo)\nFunciona de forma muito parecida com o range do Python. Ele gera números em um intervalo com um passo definido. Importante: o valor fim não é incluído na sequência.\n# Gera números de 0 a 1 (sem incluir o 1), com passo de 0.2 tempo = np.arange(0, 1, 0.2) print(tempo) # Saída: [0. , 0.2, 0.4, 0.6, 0.8]Quando usar? Ideal quando o tamanho do passo entre os pontos é o mais importante.\nnp.linspace(início, fim, quantidade_de_pontos)\nGera um número específico de pontos igualmente espaçados entre o início e o fim. Diferente do arange, o valor fim é incluído por padrão.\n# Gera 5 pontos igualmente espaçados entre 0 e 1 (incluindo ambos) posicao = np.linspace(0, 1, 5) print(posicao) # Saída: [0. , 0.25, 0.5 , 0.75, 1. ]Quando usar? Ideal quando o número total de pontos é mais importante que o passo exato.\nAleatoriedade e reprodutibilidade# Para simulações (como o Método de Monte Carlo) ou para gerar dados de teste, precisamos de números aleatórios. A prática moderna no NumPy é usar um \u0026ldquo;Gerador\u0026rdquo;.\n# Cria um gerador de números aleatórios. A \u0026#39;seed\u0026#39; é uma semente. # Usar a mesma seed (ex: 42) garante que os mesmos números \u0026#34;aleatórios\u0026#34; sejam gerados sempre. # Isso é fundamental para que seus experimentos e simulações sejam REPRODUTÍVEIS. rng = np.random.default_rng(seed=42) # Gera 6 números inteiros aleatórios entre 50 (inclusivo) e 100 (exclusivo) inteiros_aleatorios = rng.integers(low=50, high=100, size=6) # Gera 5 números decimais aleatórios uniformemente distribuídos entre 0.0 e 1.0 reais_aleatorios = rng.random(5) print(\u0026#34;Inteiros gerados:\u0026#34;, inteiros_aleatorios) print(\u0026#34;Reais gerados:\u0026#34;, reais_aleatorios) Dica: Sempre defina uma seed quando estiver desenvolvendo um código que usa aleatoriedade. Isso garante que você possa rodar o código novamente e obter exatamente os mesmos resultados, o que é crucial para depuração e validação.\nAnatomia de um Array: shape, ndim e dtype# Todo array NumPy possui atributos essenciais que descrevem sua estrutura.\n# Cria um vetor com 12 elementos (de 0 a 11) x = np.arange(12) print(\u0026#34;Vetor original:\u0026#34;, x) print(\u0026#34;Shape:\u0026#34;, x.shape) # Formato -\u0026gt; (12,) print(\u0026#34;Ndim:\u0026#34;, x.ndim) # Número de dimensões -\u0026gt; 1 print(\u0026#34;Dtype:\u0026#34;, x.dtype) # Tipo do dado -\u0026gt; int64 # Agora, vamos remodelar esse vetor para uma matriz 3x4 # O número total de elementos (12) deve ser mantido. X = x.reshape(3, 4) print(\u0026#34;\\nMatriz remodelada:\\n\u0026#34;, X) print(\u0026#34;Shape:\u0026#34;, X.shape) # Formato -\u0026gt; (3, 4) print(\u0026#34;Ndim:\u0026#34;, X.ndim) # Número de dimensões -\u0026gt; 2 Transformações úteis: .reshape(linhas, colunas): Modifica o formato do array, sem alterar os dados. .flatten() ou .ravel(): Transforma qualquer matriz em um vetor 1D. .astype(novo_tipo): Converte o tipo de dado do array (ex: de inteiro para float). X.astype(np.float32) economiza memória se a precisão de 64 bits não for necessária. Indexação e Fatiamento (Slicing): Acessando seus Dados# Esta é a forma de selecionar elementos, linhas, colunas ou sub-regiões de um array. A indexação em Python começa em zero.\nIndexação 1D (Vetores):\na = np.array([10, 20, 30, 40, 50]) print(\u0026#34;Primeiro elemento:\u0026#34;, a[0]) # Pega o elemento no índice 0 -\u0026gt; 10 print(\u0026#34;Último elemento:\u0026#34;, a[-1]) # Pega o último elemento -\u0026gt; 50 print(\u0026#34;Do segundo ao quarto:\u0026#34;, a[1:4]) # Pega do índice 1 até o 4 (sem incluir o 4) -\u0026gt; [20, 30, 40]Indexação em 2D (Matrizes) - matriz[linha, coluna]\nm = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) print(\u0026#34;Elemento na primeira linha, primeira coluna:\u0026#34;, m[0, 0]) # -\u0026gt; 1 # O símbolo \u0026#39;:\u0026#39; significa \u0026#34;todos os elementos daquela dimensão\u0026#34; print(\u0026#34;Toda a segunda linha:\u0026#34;, m[1, :]) # Pega a linha de índice 1 -\u0026gt; [4, 5, 6] print(\u0026#34;Toda a terceira coluna:\u0026#34;, m[:, 2]) # Pega a coluna de índice 2 -\u0026gt; [3, 6, 9]Indexação Booleana (Filtragem por Condição)\nEssa é uma técnica extremamente poderosa para filtrar dados.\nv = np.array([1, 2, 3, 4, 5, -1, -2]) # 1. Criar uma condição (máscara) mascara = v \u0026gt; 2 print(\u0026#34;Máscara booleana:\u0026#34;, mascara) # -\u0026gt; [False, False, True, True, True, False, False] # 2. Usar a máscara para selecionar apenas os elementos onde a condição é True print(\u0026#34;Elementos maiores que 2:\u0026#34;, v[mascara]) # -\u0026gt; [3, 4, 5] # Pode ser feito em uma única linha: print(\u0026#34;Elementos positivos:\u0026#34;, v[v \u0026gt; 0]) # -\u0026gt; [1, 2, 3, 4, 5] Operações vetorizadas \u0026amp; broadcasting# Operações matemáticas entre arrays são aplicadas elemento a elemento, sem a necessidade de loops explícitos. Isso é chamado de vetorização e é uma das principais razões para a eficiência do NumPy.\nx = np.array([1, 2, 3]) y = np.array([10, 20, 30]) # Operações elemento a elemento (muito mais rápido que um laço for) soma = x + y # -\u0026gt; [11, 22, 33] multiplicacao = x * y # -\u0026gt; [10, 40, 90] potencia = x ** 2 # -\u0026gt; [1, 4, 9] # Operação com um escalar (um único número) multiplicado_por_2 = x * 2 # -\u0026gt; [2, 4, 6] print(\u0026#34;Soma:\u0026#34;, soma) print(\u0026#34;Multiplicado por 2:\u0026#34;, multiplicado_por_2)Broadcasting: Operando com Arrays de Formatos Diferentes O Broadcasting é um mecanismo poderoso que permite ao NumPy realizar operações em arrays de formatos diferentes. A regra geral é: se uma dimensão em um dos arrays for 1, ela pode ser \u0026ldquo;esticada\u0026rdquo; para corresponder à dimensão do outro array.\nExemplo prático: Somar um vetor a cada linha de uma matriz.\n# Matriz 2x3 A = np.array([[1, 2, 3], [4, 5, 6]]) # Vetor com 3 elementos b = np.array([10, 20, 30]) # O NumPy \u0026#34;estica\u0026#34; ou \u0026#34;transmite\u0026#34; (broadcasts) o vetor \u0026#39;b\u0026#39; # para cada linha da matriz \u0026#39;A\u0026#39; antes de somar. # A forma de \u0026#39;b\u0026#39; (3,) é compatível com a segunda dimensão de \u0026#39;A\u0026#39; (2, 3). C = A + b print(\u0026#34;Matriz A:\\n\u0026#34;, A) print(\u0026#34;\\nVetor b:\u0026#34;, b) print(\u0026#34;\\nResultado A + b:\\n\u0026#34;, C) # [[11, 22, 33], # [14, 25, 36]]Isso evita a necessidade de criar uma matriz com cópias do vetor b, economizando memória e sendo mais eficiente.\nÁlgebra linear básica# Produto matricial, transposta, determinante, inversa, resolução de sistemas:\nA = np.array([[3, 1], [1, 2]]) b = np.array([9, 8]) # produto matricial C = A @ A # ou np.dot(A, A) # resolver A x = b x = np.linalg.solve(A, b) # inversa e determinante (use com cuidado) invA = np.linalg.inv(A) detA = np.linalg.det(A) print(\u0026#34;x =\u0026#34;, x) Nota: usar np.linalg.solve é preferível a calcular inv(A) e multiplicar, por estabilidade e desempenho.\nFunções estatísticas e agregações# Analisar um conjunto de dados é uma tarefa comum. NumPy oferece funções estatísticas otimizadas.\n# Dados de um ensaio (ex: resistência em MPa) dados = np.array([10.2, 20.5, 31.0, 39.8, 50.1]) print(\u0026#34;Média:\u0026#34;, np.mean(dados)) print(\u0026#34;Mediana:\u0026#34;, np.median(dados)) print(\u0026#34;Desvio Padrão:\u0026#34;, np.std(dados)) print(\u0026#34;Valor Mínimo:\u0026#34;, np.min(dados)) print(\u0026#34;Valor Máximo:\u0026#34;, np.max(dados)) print(\u0026#34;Soma Total:\u0026#34;, np.sum(dados))Agregações por Eixo em Matrizes Você pode calcular estatísticas ao longo de linhas ou colunas de uma matriz usando o argumento axis.\naxis=0: Opera \u0026ldquo;para baixo\u0026rdquo; (ao longo das linhas), resultando em um valor por coluna. axis=1: Opera \u0026ldquo;para o lado\u0026rdquo; (ao longo das colunas), resultando em um valor por linha. M = np.arange(12).reshape(3, 4) # [[ 0, 1, 2, 3], # [ 4, 5, 6, 7], # [ 8, 9, 10, 11]] # Calcula a média de cada coluna media_colunas = np.mean(M, axis=0) print(\u0026#34;Matriz M:\\n\u0026#34;, M) print(\u0026#34;\\nMédia por coluna:\u0026#34;, media_colunas) # -\u0026gt; [4., 5., 6., 7.] # Calcula a soma de cada linha soma_linhas = np.sum(M, axis=1) print(\u0026#34;Soma por linha:\u0026#34;, soma_linhas) # -\u0026gt; [ 6, 22, 38] Referências rápidas# Documentação oficial: numpy.org/doc Quickstart: numpy.org/devdocs/user/quickstart Observações finais# Dominar NumPy torna muito mais eficiente o trabalho com Pandas, SciPy e frameworks de redes neurais.\nEste capítulo serve como fundação para todo o conteúdo posterior do NeuralBook.\n"}]